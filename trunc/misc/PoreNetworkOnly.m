%Changing the BC from LTR instead of DownToUp
%Final version of 2D Hexagonal system copied from the last working modified Diffusion-Advection file.
%this is used to find the proper amount of Poer sizes by mapping to
%another dense squre like distribusion generated by FFT.
tic
clear all
%close all
%clc
n=120;    % n should be a factor of 4, rpresents X axis
m=36;    %m should be even, represents Y axis
nodes=zeros(m,n);  %in the matrix, m represents y-axis and n does x-axis
actnodes=m*n/2;  %only when n is factor of 4

x_actnode=zeros(actnodes,1);
y_actnode=zeros(actnodes,1);

yx_actnodecon=cell(actnodes,3);

pores_no=n/2*(m-1)+(n/2-1)*fix(m/2);    % n should be even (better to be factor of 4, m also even for this formula
pore_pos=zeros(pores_no,4);
%ver 1.6, to define the type of pore in 3rd colomn
% to define if pores connected to BCs (BC1 or BC2 or ...) in 4th colomn
pore_iter=0;

%make sure this value is equal to what u have in your random generator
%make sure ur pore length, dt and pore radi make sence
porelength=.001;

realX = [repmat([porelength/2 porelength],1,n/2) porelength/2];
node_realX=zeros(actnodes,1);
node_realY=zeros(actnodes,1);

stateoddX=1;
for i=1:n
    if i/2 ~= round(i/2)    %odd x
        for j=1:m/2
            
            if stateoddX==1; k=2*j-1;stateevenX=2;else k=2*j;stateevenX=4;end       %k is actual y-axis position of active node
            actnodeno=j+m/2*(i-1);
            nodes(k,i)=actnodeno;
            x_actnode(actnodeno)=i;
            y_actnode(actnodeno)=k;
            
            %------------real position of nodes -------------
            node_realX(actnodeno)=sum(realX(1:i-1));
            node_realY(actnodeno)=(k-1)*sqrt(3)*porelength/2;
            %------------------------------------------------
            
            yx_actnodecon{actnodeno,1}=[k+1,i+1];
            yx_actnodecon{actnodeno,2}=[k-1,i+1];
            yx_actnodecon{actnodeno,3}=[k,i-1];
        end
        
    else    %even x
        for j=1:m/2
            if stateevenX==2; k=2*j;stateoddX=3;else k=2*j-1;stateoddX=1;end    %k is actual y-axis position of active node
            actnodeno=j+m/2*(i-1);
            nodes(k,i)=actnodeno;
            x_actnode(actnodeno)=i;
            y_actnode(actnodeno)=k;
            
            %------------real position of nodes -------------
            node_realX(actnodeno)=sum(realX(1:i-1));
            node_realY(actnodeno)=(k-1)*sqrt(3)*porelength/2;
            %------------------------------------------------
            
            i2=actnodeno;
            %because all nodes around are Fard nodes, we use the k=2*j-1 to
            %find the actual number of it for
            
            yx_actnodecon{actnodeno,1}=[k-1,i-1];%((---1---))
            
            if y_actnode(actnodeno)~=1
            pore_iter=pore_iter+1;
            pore_pos(pore_iter,2)=i2;            %pore ended node, even X
            if stateevenX==2
                pore_pos(pore_iter,1)=(yx_actnodecon{i2,1}(1)+1)/2+m/2*(yx_actnodecon{i2,1}(2)-1);%j=(k+1)/2 from k=2*j-1
            else
                pore_pos(pore_iter,1)=yx_actnodecon{i2,1}(1)/2+m/2*(yx_actnodecon{i2,1}(2)-1);%j=k/2 from k=2*j
            end
            pore_pos(pore_iter,3)=1;
            end
            
            yx_actnodecon{actnodeno,2}=[k+1,i-1];%((---2---))
            
            if y_actnode(actnodeno)~=m
            pore_iter=pore_iter+1;
            pore_pos(pore_iter,2)=i2;            %pore ended node, even X
            if stateevenX==2
                pore_pos(pore_iter,1)=(yx_actnodecon{i2,2}(1)+1)/2+m/2*(yx_actnodecon{i2,2}(2)-1);%j=(k+1)/2 from k=2*j-1
            else
                pore_pos(pore_iter,1)=yx_actnodecon{i2,2}(1)/2+m/2*(yx_actnodecon{i2,2}(2)-1);%j=k/2 from k=2*j
            end
            pore_pos(pore_iter,3)=2;
            end
            
            yx_actnodecon{actnodeno,3}=[k,i+1];%((---3---))
            
            if x_actnode(actnodeno)~=n
            pore_iter=pore_iter+1;
            pore_pos(pore_iter,2)=i2;            %pore ended node, even X
            if stateevenX==2
                pore_pos(pore_iter,1)=yx_actnodecon{i2,3}(1)/2+m/2*(yx_actnodecon{i2,3}(2)-1);%j=k/2 from k=2*j
            else
                pore_pos(pore_iter,1)=(yx_actnodecon{i2,3}(1)+1)/2+m/2*(yx_actnodecon{i2,3}(2)-1);%j=(k+1)/2 from k=2*j-1
            end
            pore_pos(pore_iter,3)=3;
            end
            
        end
        
    end
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% we can remove "nodes" variable, was for test to see if network works

node_no=actnodeno;


% %%%%%%%%%%%%%pPplotting the network points and pores%%%%%%%%%%%%%%%
% axis([1 n 1 m])
% hold on
% for i=1:node_no
%     x_values=[yx_actnodecon{i,1}(2) x_actnode(i) yx_actnodecon{i,2}(2)...
%         x_actnode(i) yx_actnodecon{i,3}(2)];
%     y_values=[yx_actnodecon{i,1}(1) y_actnode(i) yx_actnodecon{i,2}(1)...
%         y_actnode(i) yx_actnodecon{i,3}(1)];
%     line (x_values,y_values);
% end
% plot(x_actnode,y_actnode,'g+')
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%maybe we can delete yx_actnodecon to free memory and use x_actnode and
%y_actnode and node_pores_nodes instead from now on
clear yx_actnodecon




%0O0btaining the number(id) of pores connected to a specific node.
% V1.3, finding nodes and pores connected to a specific node.
node_pores_nodes=zeros(actnodes, 7);
%V1.6 added, the last colomn for specifying if the node is BC or not.

maxporepernod=0;    %number of allowed pore per node to inc the speed
for inod=1:actnodes
    if (x_actnode(inod)==1) || (x_actnode(inod)==n)
        if (y_actnode(inod)==1) || (y_actnode(inod)==m)
            maxporepernod=1;
        else
            maxporepernod=2;
        end
    else
        if (y_actnode(inod)==1) || (y_actnode(inod)==m)
            maxporepernod=2;
        else
            maxporepernod=3;
        end
    end
    
    %=========== determining if node is BC1 or BC2 or none ======
    if x_actnode(inod)==1
        node_pores_nodes(inod,7)=1;
    elseif x_actnode(inod)==n
        node_pores_nodes(inod,7)=2;
    end
    %============================================================
    
    if rem(x_actnode(inod),2)~=0  %odd x, first column seek, fard kind
        seekcol=1;
        anothercol=2;
        type_node=1;%fard
    else                          %even x, 2nd column seek, zoj kind
        seekcol=2;
        anothercol=1;
        type_node=2;%zoj
    end
    
    i2=0;
    for i=1:pores_no  %here we determine the node kind (fard or zoj) in order to determine the order of its neibours
        if i2==maxporepernod, break; end
        if pore_pos(i,seekcol)==inod
            i2=i2+1;
            node_con=pore_pos(i,anothercol);
            if type_node == 1
                if y_actnode(node_con)<y_actnode(inod)
                    position=1;
                elseif y_actnode(node_con)==y_actnode(inod)
                    position=2;
                elseif y_actnode(node_con)>y_actnode(inod)
                    position=3; 
                end
            else
                if y_actnode(node_con)<y_actnode(inod)
                    position=1;
                elseif y_actnode(node_con)==y_actnode(inod)
                    position=3;
                elseif y_actnode(node_con)>y_actnode(inod)
                    position=2;
                end
            end
            node_pores_nodes(inod,position)=i;
            %cols 1-3 for pores
            node_pores_nodes(inod,position+3)=pore_pos(i,anothercol);
            %cols 4-6 for nodes connected to those pores
            
            %====V1.6, if pores connected to BCs ===========
            if (x_actnode(inod)==n)||(x_actnode(node_con)==n)
                pore_pos(i,4)=2;
            end
            if (x_actnode(inod)==1)||(x_actnode(node_con)==1)
                pore_pos(i,4)=1;
            end
            %===============================================
        end
    end
end


%//////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
%Ver 1.8 to find the real places of nodes (X,Y) based on pore length unit
node_realXY=[node_realX node_realY];
pore_diff_XY=(node_realXY(pore_pos(:,1),:)-node_realXY(pore_pos(:,2),:))/2;
pore_realX=node_realXY(pore_pos(:,2),1)+pore_diff_XY(:,1);
pore_realY=node_realXY(pore_pos(:,2),2)+pore_diff_XY(:,2);
pore_realXY=[pore_realX pore_realY];

% figure;scatter(node_realXY(:,1),node_realXY(:,2),50,'.')
% axis equal
% %axis([0 .09 0 .031])%subject to change indeed
% figure;scatter(pore_realXY(:,1),pore_realXY(:,2),50,'.')
% axis equal
% %axis([0 .09 0 .031])%subject to change indeed
%//////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


%==============================================================
%Finding the SCHEMATIC position of the center of pores for ploting the fluxes in media
xpore=zeros(pores_no,1);
ypore=zeros(pores_no,1);

logx=x_actnode(pore_pos(:,2))-x_actnode(pore_pos(:,1));
xpore(logx==-1)=x_actnode(pore_pos((logx==-1),2))+.5;
xpore(logx==1)=x_actnode(pore_pos((logx==1),1))+.5;
%xpore(logx==0)=x_actnode(pore_pos((logx==0),1));
%for differenet state that hexagonals have a paralel side to X not Y

logy=y_actnode(pore_pos(:,2))-y_actnode(pore_pos(:,1));
ypore(logy==-1)=y_actnode(pore_pos((logy==-1),2))+.5;
ypore(logy==1)=y_actnode(pore_pos((logy==1),1))+.5;
ypore(logy==0)=y_actnode(pore_pos((logy==0),1));

clear logx logy
%==============================================================




%************************* Conductivity,Diameteres *********************************
%Definition of the Conductivity(inverse Resistivity) of pores 

%for i=1:5;radi_het(:,i)=abs(0.16e-3+ sqrt(5e-9).*randn(pores_no,1));end
for i_file=3:3
file_order=[1,25,5];
radi_file=sprintf('radi_sigma2e-9_lx00%d',file_order(i_file));
load(radi_file,'radi_het','desired_DH')

for i_radi=1:1

%load('radi_sigma2e-9_lx005',sprintf('radi%d',i_radi))
%radi=eval(sprintf('radi%d',i_radi));

radi=radi_het(:,i_radi);

%radi=160e-6*ones(pores_no,1);

mio_water=8.94e-4;
Cond=pi.*radi.^4./(8*mio_water*porelength);
vol=pi.*radi.^2.*porelength;
pore_area=pi.*radi.^2;

%baraye didane chegoonegie neveshtane anvae mokhtalefe Res va Con, be
%version haye ghabli V1.5 moraje'e shavad
%*************************** Conductivity,Diameteres (/end)**************************




%----------------- "Changed BCs" diagonals of Sparse matrix construction ---------------------
nodes_notBC=node_no-m; %only for even m

downdiag=zeros(nodes_notBC,1);
downl=downdiag;
downr=downdiag;

updiag=downdiag;
upr=updiag;
upl=updiag;

bvector=zeros(nodes_notBC,1);
maindiag=zeros(nodes_notBC,1);

iup=m;
idown=0;
idiag=0;

for inod=m/2+1:node_no-m/2
    iup=iup+1;
    idown=idown+1;
    idiag=idiag+1;
    if rem(x_actnode(inod),2)==0 %zoj node
       updiag(idiag)=-Cond(node_pores_nodes(inod,3));
%        updiag(idiag)=node_pores_nodes(inod,3+3);%to check if its right node
       
       if idown==node_pores_nodes(inod,4)
           downdiag(idiag)=-Cond(node_pores_nodes(inod,1));
           if node_pores_nodes(inod,2)~=0,downr(idiag)=-Cond(node_pores_nodes(inod,2));end
%            downr(idiag)=node_pores_nodes(inod,2+3);%to check if its right node
%            downdiag(idiag)=node_pores_nodes(inod,1+3);
       else
           downdiag(idiag)=-Cond(node_pores_nodes(inod,2));
           if node_pores_nodes(inod,1)~=0,downl(idiag)=-Cond(node_pores_nodes(inod,1));end
%            downl(idiag)=node_pores_nodes(inod,1+3);%to check if its right node
%            downdiag(idiag)=node_pores_nodes(inod,2+3);
       end
       
    else    %fard node
       downdiag(idiag)=-Cond(node_pores_nodes(inod,2));
%        downdiag(idiag)=node_pores_nodes(inod,2+3);%to check if its right node
       
       if iup==node_pores_nodes(inod,4)
           updiag(idiag)=-Cond(node_pores_nodes(inod,1));
           if node_pores_nodes(inod,3)~=0,upr(idiag)=-Cond(node_pores_nodes(inod,3));end
%            upr(idiag)=node_pores_nodes(inod,3+3);%to check if its right node
%            updiag(idiag)=node_pores_nodes(inod,1+3);
       else
           updiag(idiag)=-Cond(node_pores_nodes(inod,3));
           if node_pores_nodes(inod,1)~=0,upl(idiag)=-Cond(node_pores_nodes(inod,1));end
%            upl(idiag)=node_pores_nodes(inod,1+3);%to check if its right node
%            updiag(idiag)=node_pores_nodes(inod,3+3);
       end
    end
    
end


%BC: the head pressure values in starting and ending nodes
%each applied to the first n/2 and last n/2 nodes in the structure
head_begin=desired_DH(i_radi);%62.15 for 160mic%248.6 for 80mic;%deltaH(i_radi);
head_end=0;

%downl is always zero for bv_begin and so is upl for bv_end, so we removed them in next lines but keeping the original command
% bv_end=[upl(end-m/2+1:end),updiag(end-m/2+1:end),upr(end-m/2+1:end)];
% bv_begin=[downl(1:m/2),downdiag(1:m/2),downr(1:m/2)];

bv_end=[updiag(end-m/2+1:end),upr(end-m/2+1:end)];
bv_begin=[downdiag(1:m/2),downr(1:m/2)];
for inod=1:m/2
    bvb_nozero=bv_begin(inod,:);
    bvn_nozero=bv_end(end-inod+1,:);
%     bvb_nozero(bvb_nozero==0)=[];
%     bvn_nozero(bvn_nozero==0)=[];
    
%minus sign (-) because that Bvector is in the other side of the equation
    bvector(inod)=-sum(bvb_nozero)*head_begin;
    bvector(end-inod+1)=-sum(bvn_nozero)*head_end;
end


indmaindiag=node_pores_nodes(m/2+1:end-m/2,[1 2 3]);
for inod=1:nodes_notBC
    none_zero_pores=indmaindiag(inod,:);
    none_zero_pores(none_zero_pores==0)=[];
    maindiag(inod,1)=sum(Cond(none_zero_pores));
end


Amat3=spdiags([upr updiag upl maindiag downr downdiag downl], [-(m/2+1) -m/2 -(m/2-1) 0 m/2-1 m/2 m/2+1], nodes_notBC, nodes_notBC);
%Amat=spdiags([downl downdiag downr maindiag upl updiag upr], [-(m/2+1) -m/2 -(m/2-1) 0 m/2-1 m/2 m/2+1], nodes_notBC, nodes_notBC);
head_calc = Amat3\bvector;


%---------------------------Matrix solved (/end)--------------------------------------





%-------------------------- Head values over medium & Fluxes -----------------------
head_BC1=repmat(head_begin,m/2,1);
head_BC2=repmat(head_end,m/2,1);
head = [head_BC1;head_calc;head_BC2];

%flowartes inside the pores, predefind flow directions from pores_pos
%from fard to zoj
flux=-Cond.*(head(pore_pos(:,2))-head(pore_pos(:,1)));
%----------------------------plots---------------------------------------

%figure;scatter(node_realX,node_realY,50,head,'.');
%figure;scatter(pore_realX,pore_realY,50,flux,'.');

figure;
scatter(pore_realXY(:,1), pore_realXY(:,2), 50, flux, '.');
axis equal;

%plotting heads over the domain
% z = reshape(head, m/2, length(head)/(m/2));
% y = reshape(y_actnode, m/2, length(y_actnode)/(m/2));
% x = reshape(x_actnode, m/2, length(x_actnode)/(m/2));
% 
% figure;surf(x,y,z) %heads
% contour(x,y,z);%heads in nodes

%figure;plot3k_lable({xpore ypore abs(flux)},[],[],{},6);% fluxes in pores

%figure;plot3k_lable({xpore ypore Cond},[],[],{},6);% Conductivity of pores

%--------------------------------------------------------------------
%-------------------------- Heads & Fluxes (/end)-----------------------

%---------------------------- total flowrate ----------------------------
%some commands to find out the total inlet and oulet Q
pore_bc_1=find(pore_pos(:,4)==1);
inletQ=sum(abs(flux(pore_bc_1)));
pore_bc_2=find(pore_pos(:,4)==2);
outletQ=sum(abs(flux(pore_bc_2)));

vol_tot(i_radi)=sum(vol);

desired_Q(i_radi)=.014*vol_tot(i_radi);

desired_DH(i_radi)=desired_Q(i_radi)*head_begin/inletQ;
flux_adv_abs(:,i_radi)=abs(flux);
%--------------------------------------------------------------------

end
%save(radi_file,'desired_DH','flux_adv_abs','-append')
%save(radi_file,'flux_adv_abs','-append')
end



